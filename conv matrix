import numpy as np
import scipy
from scipy import signal


"""
Creation of convolution matrix
given size of matrix

Step 1: Determine A
Step 3: Multiply x_vect by convolution matrix A
"""

def conv_recurse(conv, x, conv_i, conv_j, x_i, x_j, overlap):

    """
    Overlap between two matrices and values corresponding to them
    Returns list over_lap of positions (according to ref matrix) and
    corresponding value

    Works by comparing the overlap in position beween matrices
    denoted by
    (conv_i, conv_j) representing pos in convolution
    and
    (x_i, x_) representing pos in matrix x
    """

    #print("Positions in conv {convis} and x {xis}".format(convis = (conv_i, conv_j), xis = (x_i, x_j)))

    # position in conv corresponds to ref matrix
    # value in convolution matrix
    overlap.append(((x_i, x_j), conv[(x_i, x_j)]))

    # going up
    #boundary conditions for both and haven't been visited?
    if (conv_i > 0) and (x_i > 0):
        if not (((x_i-1, x_j), conv[(x_i-1, x_j)]) in overlap):
            conv_recurse(conv, x, conv_i-1, conv_j, x_i-1, x_j, overlap)


    # going left
    if (conv_j > 0) and (x_j > 0):
        if not (((x_i, x_j-1), conv[(x_i, x_j-1)]) in overlap):
            conv_recurse(conv, x, conv_i, conv_j-1, x_i, x_j-1, overlap)

    # going right
    if ((conv_i < len(conv)-1) and (x_i < len(x)-1)):
        if not (((x_i+1, x_j), conv[(x_i+1, x_j)]) in overlap):
            conv_recurse(conv, x, conv_i+1, conv_j, x_i+1, x_j, overlap)
    # going down
    #check to see if reached max row
    if ((conv_j < len(conv[0])-1) and (x_j < len(x[0])-1)):
        if not (((x_i, x_j+1), conv[(x_i, x_j+1)]) in overlap):
            conv_recurse(conv, x, conv_i, conv_j+1, x_i, x_j+1, overlap)
    return
"""
##### Testing
conv_matrix = np.random.random((3, 3))
x = np.random.random((3, 3))

print("conv_matrix:\n", conv_matrix )
print("x:\n", x )

"""




def conv_helper(overlap,  row,   conv_A):

    """
    Mmanipulates matrix A based on convolution
    # IDEA: Inefficient to recreate reference matrix every time
    """
        ### reference matrix

    ref = np.zeros(x.shape)
    count = 0 # for assining values to matrix
    for i in range(len(ref)):
        for j in range(len(ref[i])):
            ref[i][j] = count
            count+=1
    # print("entering conv_helper \n")
    # print("overlap", overlap)

    # print(test)
    for pos_val in overlap:
        pos = ref[pos_val[0]]
        # print("ele, ", ele[0], " pos ", pos)
        val = pos_val[1]
        conv_A[row][int(pos)] = val
    # print("updated conv_A", conv_A)
    # print("\n exiting conv_helper", "\n")
    return

def conv(conv, x):
    """
    Works with prev functions to return convolution matrix with 0 padding.
    """

    #initiation of A
    conv_A = np.zeros((len(x)*len(x[0]), len(x)*len(x[0])))

    #corresponds to row of A, which totals num of elements in x
    update_row = 0
    # conv every element
    for i in range(len(x)):
        for j in range(len(x[0])):
            overlap = []
            # print("lenght: ", int((len(x)/2.)))
            conv_i = int((len(x)/2.))
            conv_j = int((len(x[0])/2.))
            x_i = i
            x_j = j

            conv_recurse(conv, x, conv_i, conv_j, x_i, x_j, overlap)
            #print(overlap)
            conv_helper(overlap, update_row, conv_A)
            update_row +=1
    return conv_A

def print_matrix(matrix):

    """
    Prints numpy array in speecific way
    """
    print("\n\n\nPrinting Matrix ######################\n\n")
    row_count = 0
    for row in range(len(matrix)):
        print("########### starting new row {row} #############".format(row = row_count))
        for col in range(len(matrix[0])):
            print("element in position ({i}, {jth})".format(i = row, jth = col))
            print(" is : {val}".format(val = matrix[row][col]))



###### TESTTING row manipulation of A

#print_matrix(conv(conv_matrix, x))

        #conv_A[(0, pos)]  = val
#######

#######
####

conv_matrix = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
x = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]

conv_matrix = np.array(conv_matrix)

numpy_conv = signal.convolve2d(conv_matrix, x, mode='same')
x = np.array(x)
x_vect = x.flatten('F')

calc_conv = conv(conv_matrix, x).dot(x_vect)

# print("numpy's conv,", numpy_conv)
# print("calc'ed conv with full matrix", calc_conv)

###### Testing to see if my convolution matrix works for convolution using
###### pyuthon's built in convolution functions

print(np.equal(numpy_conv.flatten('F'), calc_conv))
#
# # random is odd by odd matrix
# conv_matrix = np.random.random((3, 3))
# x = np.random.random((3, 3))
# x_vect = x.flatten('F')
# # print("conv_matrix:\n", conv_matrix )
# print("x:\n", x )
# print("conv_matrix:\n", conv_matrix )
# # print(conv(conv_matrix, x))
